package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.64

import (
	"context"
	"errors"
	"forum/auth"
	"forum/graph/model"
	"forum/loaders"
	sm "forum/system_models"
	"forum/system_models/conversion"
)

// Children is the resolver for the children field.
func (r *commentResolver) Children(ctx context.Context, obj *model.Comment, limit *int32, offset *int32) (comments []*model.Comment, err error) {
	_, err = auth.GetUserFromContext(ctx)
	if err != nil {
		return
	}

	commentsCtx := sm.CommentCtx{PostId: obj.PostID, ParentId: obj.ID}

	res, dbErr := loaders.GetNearestChildishComments(ctx, commentsCtx, int(*limit), int(*offset))
	if dbErr != nil {
		err = errors.New("база данных не смогла обработать запрос")
		return
	}

	comments = conversion.ConvArrPtrComment(res)

	return
}

// CreatePost is the resolver for the createPost field.
func (r *mutationResolver) CreatePost(ctx context.Context, title string, content string, allowComments bool) (*model.Post, error) {
	author, err := auth.GetUserFromContext(ctx)
	if err != nil {
		return nil, err
	}

	post, dbErr := r.Dao.CreatePost(sm.User(author), title, content, allowComments)
	if dbErr != nil {
		r.DbErrorsLog.Println(dbErr)
		err = errors.New("база данных не смогла обработать запрос")
		return nil, err
	}
	res := conversion.ConvPost(post)

	return &res, err
}

// CreateComment is the resolver for the createComment field.
func (r *mutationResolver) CreateComment(ctx context.Context, postID string, parentID *string, content string) (*model.Comment, error) {
	author, err := auth.GetUserFromContext(ctx)
	if err != nil {
		return nil, err
	}

	if len(content) > 2000 {
		content = content[:2000]
	}

	comment, dbErr := r.Dao.CreateComment(sm.User(author), postID, parentID, content)
	if dbErr != nil {
		r.DbErrorsLog.Println(dbErr)
		err = errors.New("не удалось создать комментарий, возможно автор поста запретил их оставлять")
		return nil, err
	}

	res := conversion.ConvComment(comment)

	return &res, err
}

// AllowComments is the resolver for the allowComments field.
func (r *mutationResolver) AllowComments(ctx context.Context, postID string) (ok bool, ee error) {
	user, err := auth.GetUserFromContext(ctx)
	if err != nil {
		return false, err
	}

	dbErr := r.Dao.UpdateCommentingAccess(user.Username, postID, true)
	if dbErr != nil {
		r.DbErrorsLog.Println(dbErr)
		err = errors.New("база данных не смогла обработать запрос")
		return false, err
	}
	return true, nil
}

// DisallowComments is the resolver for the disallowComments field.
func (r *mutationResolver) DisallowComments(ctx context.Context, postID string) (ok bool, ee error) {
	user, err := auth.GetUserFromContext(ctx)
	if err != nil {
		return false, err
	}

	dbErr := r.Dao.UpdateCommentingAccess(user.Username, postID, false)
	if dbErr != nil {
		r.DbErrorsLog.Println(dbErr)
		err = errors.New("база данных не смогла обработать запрос")
		return false, err
	}
	return true, nil
}

// Posts is the resolver for the posts field.
func (r *queryResolver) Posts(ctx context.Context, limit *int32, offset *int32) ([]*model.Post, error) {
	_, err := auth.GetUserFromContext(ctx)
	if err != nil {
		return nil, err
	}
	posts, dbErr := r.Dao.ReadAllPosts(int(*limit), int(*offset))
	if dbErr != nil {
		r.DbErrorsLog.Println(dbErr)
		err = errors.New("база данных не смогла обработать запрос")
	}
	res := conversion.ConvArrPtrPost(posts)

	return res, err
}

// Post is the resolver for the post field.
func (r *queryResolver) Post(ctx context.Context, id string) (*model.Post, error) {
	_, err := auth.GetUserFromContext(ctx)
	if err != nil {
		return nil, err
	}
	post, dbErr := r.Dao.ReadPostByID(id)
	if dbErr != nil {
		r.DbErrorsLog.Println(dbErr)
		err = errors.New("такого поста нет")
	}
	res := conversion.ConvPost(post)

	return &res, err
}

// PostComments is the resolver for the postComments field.
func (r *subscriptionResolver) PostComments(ctx context.Context, postID string) (<-chan *model.Comment, error) {
	commentsChan := make(chan *model.Comment)

	ch := r.Dao.ListenPostComments(ctx, postID)

	go func() {
		defer close(commentsChan)
		for {
			var upt *sm.Comment
			var ok bool
			select {
			case <-ctx.Done():
				return
			case upt, ok = <-ch:
				if !ok {
					return
				}
			}
			if upt == nil {
				continue
			}

			comment := conversion.ConvComment(*upt)

			select {
			case <-ctx.Done():
				return
			case commentsChan <- &comment:
			}
		}
	}()

	return commentsChan, nil
}

// Comment returns CommentResolver implementation.
func (r *Resolver) Comment() CommentResolver { return &commentResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type commentResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
